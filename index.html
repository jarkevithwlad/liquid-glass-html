<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Эффект Жидкого Стекла (Новая версия)</title>
    <style>
        * { box-sizing: border-box; }
        body, html { height: 100%; margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; color: white; overflow: hidden; }
        body { background-image: url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1500&q=80'); background-size: cover; background-position: center; background-attachment: fixed; display: flex; }
        .sidebar { flex: 0 0 350px; height: 100vh; padding: 25px; background-color: rgba(0, 0, 0, 0.55); overflow-y: auto; color: #e0e0e0; }
        .sidebar h2 { margin-top: 0; color: white; border-bottom: 1px solid rgba(255, 255, 255, 0.3); padding-bottom: 10px; }
        .sidebar p { line-height: 1.6; font-size: 1rem; }
        .main-content { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; text-align: center; text-shadow: 0 2px 5px rgba(0, 0, 0, 0.7); }
        .main-content h1 { font-size: 3rem; margin-bottom: 1rem; }
        .main-content p { font-size: 1.2rem; max-width: 600px; }
    </style>
</head>
<body>

    <aside class="sidebar">
        <h2>Жидкое Стекло</h2>
        <p>Этот текстовый блок добавлен специально для демонстрации эффекта искажения. Переместите "жидкую линзу" сюда, чтобы увидеть, как она влияет не только на фоновое изображение, но и на контент страницы.</p>
        <p>В основе этого эффекта лежит SVG-фильтр `feDisplacementMap`. Он берет пиксели из исходного изображения (в данном случае, всего, что находится под линзой) и смещает их в соответствии с картой смещения. Карта смещения — это невидимое изображение, где красный канал определяет смещение по горизонтали, а зеленый — по вертикали.</p>
        <p>Таким образом, создается иллюзия преломления света, как будто мы смотрим через объемный стеклянный или водный объект. Этот метод очень производительный и позволяет создавать сложные визуальные эффекты прямо в браузере с помощью CSS и SVG.</p>
        <p>Прокрутите этот блок, чтобы убедиться, что линза работает и с прокручиваемым контентом.</p>
    </aside>

    <main class="main-content">
        <h1>Эффект "Жидкое Стекло"</h1>
        <p>Искажающая линза уже активна. Перемещайте её по экрану, чтобы увидеть эффект в действии.</p>
    </main>

    <script>
    function runLiquidGlassEffect() {
      (function() {
        'use strict';
        
        if (window.liquidGlass) { window.liquidGlass.destroy(); }
        function smoothStep(a, b, t) { t = Math.max(0, Math.min(1, (t - a) / (b - a))); return t * t * (3 - 2 * t); }
        function length(x, y) { return Math.sqrt(x * x + y * y); }
        function roundedRectSDF(x, y, width, height, radius) { const qx = Math.abs(x) - width + radius; const qy = Math.abs(y) - height + radius; return Math.min(Math.max(qx, qy), 0) + length(Math.max(qx, 0), Math.max(qy, 0)) - radius; }
        function texture(x, y) { return { type: 't', x, y }; }
        function generateId() { return 'liquid-glass-' + Math.random().toString(36).substr(2, 9); }

        class Shader {
          constructor(options = {}) {
            this.width = options.width || 100; this.height = options.height || 100; this.fragment = options.fragment || ((uv) => texture(uv.x, uv.y)); this.canvasDPI = 1; this.id = generateId(); this.offset = 10;
            this.mouse = { x: 0, y: 0 }; this.mouseUsed = false;
            this.createElement(); this.setupEventListeners(); this.updateShader();
          }

          createElement() {
            this.container = document.createElement('div');
            // --- НОВОЕ РЕШЕНИЕ: Искусственный блик и убранный контраст ---
            this.container.style.cssText = `
              position: fixed;
              top: 50%; 
              left: 50%;
              transform: translate(-50%, -50%);
              width: ${this.width}px;
              height: ${this.height}px;
              overflow: hidden;
              border-radius: 150px;
              /* 1. Внешняя тень для объема + ВНУТРЕННЯЯ БЕЛАЯ тень для блика */
              box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 0 10px 2px rgba(255, 255, 255, 0.5);
              cursor: grab;
              /* 2. Убраны contrast и brightness, чтобы не было затемнения */
              backdrop-filter: url(#${this.id}_filter) blur(0.5px);
              z-index: 9999;
              pointer-events: auto;
            `;
            // --- КОНЕЦ ИЗМЕНЕНИЙ ---

            this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            this.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg'); this.svg.setAttribute('width', '0'); this.svg.setAttribute('height', '0'); this.svg.style.cssText = `position: fixed; top: 0; left: 0; pointer-events: none; z-index: 9998;`;
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs'); const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', `${this.id}_filter`); filter.setAttribute('filterUnits', 'userSpaceOnUse'); filter.setAttribute('colorInterpolationFilters', 'sRGB'); filter.setAttribute('x', '0'); filter.setAttribute('y', '0'); filter.setAttribute('width', this.width.toString()); filter.setAttribute('height', this.height.toString());
            this.feImage = document.createElementNS('http://www.w3.org/2000/svg', 'feImage'); this.feImage.setAttribute('id', `${this.id}_map`); this.feImage.setAttribute('width', this.width.toString()); this.feImage.setAttribute('height', this.height.toString());
            this.feDisplacementMap = document.createElementNS('http://www.w3.org/2000/svg', 'feDisplacementMap'); this.feDisplacementMap.setAttribute('in', 'SourceGraphic'); this.feDisplacementMap.setAttribute('in2', `${this.id}_map`); this.feDisplacementMap.setAttribute('xChannelSelector', 'R'); this.feDisplacementMap.setAttribute('yChannelSelector', 'G');
            filter.appendChild(this.feImage); filter.appendChild(this.feDisplacementMap); defs.appendChild(filter); this.svg.appendChild(defs);
            this.canvas = document.createElement('canvas'); this.canvas.width = this.width * this.canvasDPI; this.canvas.height = this.height * this.canvasDPI; this.canvas.style.display = 'none'; this.context = this.canvas.getContext('2d');
          }

          constrainPosition(x, y) { const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; const minX = this.offset; const maxX = viewportWidth - this.width - this.offset; const minY = this.offset; const maxY = viewportHeight - this.height - this.offset; const constrainedX = Math.max(minX, Math.min(maxX, x)); const constrainedY = Math.max(minY, Math.min(maxY, y)); return { x: constrainedX, y: constrainedY }; }
          setupEventListeners() { let isDragging = false; let startX, startY, initialX, initialY; this.container.addEventListener('mousedown', (e) => { isDragging = true; this.container.style.cursor = 'grabbing'; startX = e.clientX; startY = e.clientY; const rect = this.container.getBoundingClientRect(); initialX = rect.left; initialY = rect.top; e.preventDefault(); }); document.addEventListener('mousemove', (e) => { if (isDragging) { const deltaX = e.clientX - startX; const deltaY = e.clientY - startY; const newX = initialX + deltaX; const newY = initialY + deltaY; const constrained = this.constrainPosition(newX, newY); this.container.style.left = constrained.x + 'px'; this.container.style.top = constrained.y + 'px'; this.container.style.transform = 'none'; } const rect = this.container.getBoundingClientRect(); this.mouse.x = (e.clientX - rect.left) / rect.width; this.mouse.y = (e.clientY - rect.top) / rect.height; if (this.mouseUsed) { this.updateShader(); } }); document.addEventListener('mouseup', () => { isDragging = false; this.container.style.cursor = 'grab'; }); window.addEventListener('resize', () => { const rect = this.container.getBoundingClientRect(); const constrained = this.constrainPosition(rect.left, rect.top); if (rect.left !== constrained.x || rect.top !== constrained.y) { this.container.style.left = constrained.x + 'px'; this.container.style.top = constrained.y + 'px'; this.container.style.transform = 'none'; } }); }
          updateShader() { const mouseProxy = new Proxy(this.mouse, { get: (target, prop) => { this.mouseUsed = true; return target[prop]; } }); this.mouseUsed = false; const w = this.width * this.canvasDPI; const h = this.height * this.canvasDPI; const data = new Uint8ClampedArray(w * h * 4); let maxScale = 0; const rawValues = []; for (let i = 0; i < data.length; i += 4) { const x = (i / 4) % w; const y = Math.floor(i / 4 / w); const pos = this.fragment({ x: x / w, y: y / h }, mouseProxy); const dx = pos.x * w - x; const dy = pos.y * h - y; maxScale = Math.max(maxScale, Math.abs(dx), Math.abs(dy)); rawValues.push(dx, dy); } maxScale *= 0.5; let index = 0; for (let i = 0; i < data.length; i += 4) { const r = rawValues[index++] / maxScale + 0.5; const g = rawValues[index++] / maxScale + 0.5; data[i] = r * 255; data[i + 1] = g * 255; data[i + 2] = 0; data[i + 3] = 255; } this.context.putImageData(new ImageData(data, w, h), 0, 0); this.feImage.setAttributeNS('http://www.w3.org/1999/xlink', 'href', this.canvas.toDataURL()); this.feDisplacementMap.setAttribute('scale', (maxScale / this.canvasDPI).toString()); }
          appendTo(parent) { parent.appendChild(this.svg); parent.appendChild(this.container); }
          destroy() { this.svg.remove(); this.container.remove(); this.canvas.remove(); }
        }

        function createLiquidGlass() { const shader = new Shader({ width: 300, height: 200, fragment: (uv, mouse) => { const ix = uv.x - 0.5; const iy = uv.y - 0.5; const distanceToEdge = roundedRectSDF(ix, iy, 0.3, 0.2, 0.6); const displacement = smoothStep(0.8, 0, distanceToEdge - 0.15); const scaled = smoothStep(0, 1, displacement); return texture(ix * scaled + 0.5, iy * scaled + 0.5); } }); shader.appendTo(document.body); window.liquidGlass = shader; }
        createLiquidGlass();
      })();
    }
    
    runLiquidGlassEffect();
    </script>
</body>
</html>